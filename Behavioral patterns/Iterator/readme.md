# Паттерн Iterator (Итератор) на PHP

![](https://refactoring.guru/images/patterns/content/iterator/iterator-en.png)

_Идея паттерна Итератор состоит в том, чтобы вынести поведение обхода коллекции из самой коллекции в отдельный класс._  

# Аналогия из жизни
_Варианты прогулок по Риму._
![](https://refactoring.guru/images/patterns/content/iterator/iterator-comic-1-ru.png)

Вы планируете полететь в Рим и обойти все достопримечательности за пару дней. Но приехав, вы можете долго петлять узкими улочками, пытаясь найти Колизей.  

Если у вас ограниченный бюджет — не беда. Вы можете воспользоваться виртуальным гидом, скачанным на телефон, который позволит отфильтровать только интересные вам точки. А можете плюнуть и нанять локального гида, который хоть и обойдётся в копеечку, но знает город как свои пять пальцев, и сможет посвятить вас во все городские легенды.  

Таким образом, Рим выступает коллекцией достопримечательностей, а ваш мозг, навигатор или гид — итератором по коллекции. Вы, как клиентский код, можете выбрать один из итераторов, отталкиваясь от решаемой задачи и доступных ресурсов.  


# Применимость
**_Когда у вас есть сложная структура данных, и вы хотите скрыть от клиента детали её реализации (из-за сложности или вопросов безопасности)._**
* Итератор предоставляет клиенту всего несколько простых методов перебора элементов коллекции. Это не только упрощает доступ к коллекции, но и защищает её данные от неосторожных или злоумышленных действий.

_**Когда вам нужно иметь несколько вариантов обхода одной и той же структуры данных.**_
* Нетривиальные алгоритмы обхода структуры данных могут иметь довольно объёмный код. Этот код будет захламлять всё вокруг — будь то сам класс коллекции или часть бизнес-логики программы. Применив итератор, вы можете выделить код обхода структуры данных в собственный класс, упростив поддержку остального кода.

**_Когда вам хочется иметь единый интерфейс обхода различных структур данных._**
* Итератор позволяет вынести реализации различных вариантов обхода в подклассы. Это позволит легко взаимозаменять объекты итераторов, в зависимости от того, с какой структурой данных приходится работать.

# Описание

Паттерн **Iterator** (**Итератор**) — это **поведенческий** паттерн проектирования, который предоставляет способ доступа к элементам коллекции последовательно, без раскрытия внутренней структуры коллекции. Это позволяет перебирать элементы коллекции без знания о её внутреннем устройстве.

# Пример использования в PHP

## Определите интерфейс Iterator, который будет определять методы для перебора элементов:
```php
<?php

interface Iterator
{
    public function hasNext(): bool;
    public function next();
}
```

* Реализуйте класс ConcreteIterator, который будет представлять конкретный итератор:
```php
<?php

class ConcreteIterator implements Iterator
{
    private $collection;
    private $position = 0;

    public function __construct(array $collection)
    {
        $this->collection = $collection;
    }

    public function hasNext(): bool
    {
        return $this->position < count($this->collection);
    }

    public function next()
    {
        if ($this->hasNext()) {
            $item = $this->collection[$this->position];
            $this->position++;

            return $item;
        }

        return null;
    }
}
```

* Создайте класс Aggregate, который будет представлять коллекцию и возвращать итератор:

```php
<?php

class Aggregate
{
    private $collection = [];

    public function addItem($item): void
    {
        $this->collection[] = $item;
    }

    public function getIterator(): Iterator
    {
        return new ConcreteIterator($this->collection);
    }
}
```

* Теперь вы можете использовать паттерн Iterator для перебора элементов коллекции:
```php
<?php

$aggregate = new Aggregate();
$aggregate->addItem("Item 1");
$aggregate->addItem("Item 2");
$aggregate->addItem("Item 3");

$iterator = $aggregate->getIterator();

while ($iterator->hasNext()) {
    echo $iterator->next() . "\n";
}
```

## Преимущества

* Позволяет перебирать элементы коллекции без раскрытия её внутренней структуры.
* Улучшает модульность и читаемость кода.

## Недостатки

* Для каждого типа коллекции требуется своя реализация итератора.