# Паттерн Visitor (Посетитель) на PHP

![](https://refactoring.guru/images/patterns/content/visitor/visitor.png)


# Аналогия из жизни
_У страхового агента приготовлены полисы для разных видов организаций._  

Представьте начинающего страхового агента, жаждущего получить новых клиентов. Он беспорядочно посещает все дома в округе, предлагая свои услуги. Но для каждого из посещаемых типов домов у него имеется особое предложение.  
* Придя в дом к обычной семье, он предлагает оформить медицинскую страховку.
* Придя в банк, он предлагает страховку от грабежа.
* Придя на фабрику, он предлагает страховку предприятия от пожара и наводнения.

# Применимость
* Когда вам нужно выполнить какую-то операцию над всеми элементами сложной структуры объектов, например, деревом.    
  Посетитель позволяет применять одну и ту же операцию к объектам различных классов.  
*  Когда над объектами сложной структуры объектов надо выполнять некоторые не связанные между собой операции, но вы не хотите «засорять» классы такими операциями.   
   Посетитель позволяет извлечь родственные операции из классов, составляющих структуру объектов, поместив их в один класс-посетитель. Если структура объектов является общей для нескольких приложений, то паттерн позволит в каждое приложение включить только нужные операции.
* Когда новое поведение имеет смысл только для некоторых классов из существующей иерархии.  
  Посетитель позволяет определить поведение только для этих классов, оставив его пустым для всех остальных.


# Описание

Паттерн **Visitor** (**Посетитель**) — это _**поведенческий**_ паттерн проектирования, который позволяет добавлять новые операции к группе объектов, не изменяя сами объекты. Он позволяет вынести операции в отдельные классы, называемые "посетителями", и делегировать выполнение этих операций объектам.

# Пример использования в PHP

* Определите интерфейс Visitor, который будет определять методы для операций над объектами:
```php
<?php

interface Visitor
{
    public function visitElementA(ElementA $element): void;
    public function visitElementB(ElementB $element): void;
}
```

* Реализуйте конкретные классы, на которые будут "посещать" посетители:
```php
<?php

class ElementA {
    public function accept(Visitor $visitor): void
    {
        $visitor->visitElementA($this);
    }

    public function operationA(): void
    {
        echo "ElementA operation\n";
    }
}

class ElementB
{
    public function accept(Visitor $visitor): void
    {
        $visitor->visitElementB($this);
    }

    public function operationB(): void
    {
        echo "ElementB operation\n";
    }
}
```

* Создайте конкретные классы посетителей, реализующие интерфейс Visitor:
```php
<?php

class ConcreteVisitor implements Visitor
{
    public function visitElementA(ElementA $element): void
    {
        echo "ConcreteVisitor is visiting ElementA\n";
        $element->operationA();
    }

    public function visitElementB(ElementB $element): void
    {
        echo "ConcreteVisitor is visiting ElementB\n";
        $element->operationB();
    }
}
```

* Теперь вы можете использовать паттерн Visitor для выполнения операций над объектами:
```php
<?php

// Пример использования
$elementA = new ElementA();
$elementB = new ElementB();

$visitor = new ConcreteVisitor();

$elementA->accept($visitor);
// Output:
// ConcreteVisitor is visiting ElementA
// ElementA operation

$elementB->accept($visitor);
// Output:
// ConcreteVisitor is visiting ElementB
// ElementB operation
```

## Преимущества

* Позволяет добавлять новые операции к объектам, не изменяя сами объекты.
* Обеспечивает отделение алгоритмов от структур данных.
* Объединяет родственные операции в одном классе.
* Упрощает добавление операций, работающих со сложными структурами объектов. 
* Посетитель может накапливать состояние при обходе структуры элементов.

## Недостатки

* Может привести к увеличению числа классов в системе, так как для каждой новой операции может потребоваться создание нового класса посетителя.
* Паттерн не оправдан, если иерархия элементов часто меняется.
* Может привести к нарушению инкапсуляции элементов.