# Паттерн Strategy (Стратегия) на PHP

![](https://refactoring.guru/images/patterns/content/strategy/strategy.png)

## Аналогия из жизни
Различные стратегии попадания в аэропорт:
![](https://refactoring.guru/images/patterns/content/strategy/strategy-comic-1-en.png)

Вам нужно добраться до аэропорта. Можно доехать на автобусе, такси или велосипеде. Здесь вид транспорта является стратегией. Вы выбираете конкретную стратегию в зависимости от контекста — наличия денег или времени до отлёта.

## Применимость

1. Когда вам нужно использовать разные вариации какого-то алгоритма внутри одного объекта.  
   _Стратегия позволяет варьировать поведение объекта во время выполнения программы, подставляя в него различные объекты-поведения (например, отличающиеся балансом скорости и потребления ресурсов)._
2. Когда у вас есть множество похожих классов, отличающихся только некоторым поведением.  
   _Стратегия позволяет вынести отличающееся поведение в отдельную иерархию классов, а затем свести первоначальные классы к одному, сделав поведение этого класса настраиваемым._

3. Когда вы не хотите обнажать детали реализации алгоритмов для других классов.
   _Стратегия позволяет изолировать код, данные и зависимости алгоритмов от других объектов, скрыв эти детали внутри классов-стратегий._
4. Когда различные вариации алгоритмов реализованы в виде развесистого условного оператора. Каждая ветка такого оператора представляет собой вариацию алгоритма.
   _Стратегия помещает каждую лапу такого оператора в отдельный класс-стратегию. Затем контекст получает определённый объект-стратегию от клиента и делегирует ему работу. Если вдруг понадобится сменить алгоритм, в контекст можно подать другую стратегию._

# Описание

Паттерн **Strategy** (**Стратегия**) — это **_поведенческий_** паттерн проектирования, который позволяет определить семейство алгоритмов, инкапсулировать их в отдельные классы и делать их взаимозаменяемыми. Этот паттерн позволяет изменять алгоритмы независимо от клиентов, которые их используют.

# Пример использования в PHP

* Создайте интерфейс Strategy, представляющий алгоритмы:
```php
<?php

interface Strategy
{
    public function execute(int $a, int $b): int;
}
```

* Реализуйте конкретные классы, представляющие различные стратегии:
```php
<?php

class AddStrategy implements Strategy
{
    public function execute(int $a, int $b): int {
        return $a + $b;
    }
}

class SubtractStrategy implements Strategy
{
    public function execute(int $a, int $b): int
    {
        return $a - $b;
    }
}

class MultiplyStrategy implements Strategy
{
    public function execute(int $a, int $b): int {
        return $a * $b;
    }
}
```

* Создайте класс Context, который будет использовать стратегии для выполнения алгоритмов:
```php
<?php

class Context
{
    private $strategy;

    public function __construct(Strategy $strategy)
    {
        $this->strategy = $strategy;
    }

    public function executeStrategy(int $a, int $b): int
    {
        return $this->strategy->execute($a, $b);
    }
}
```

* Теперь вы можете использовать паттерн Strategy для выбора и замены алгоритмов в объекте Context:
```php
<?php

// Пример использования
$contextAdd = new Context(new AddStrategy());
echo "Add: " . $contextAdd->executeStrategy(5, 3) . PHP_EOL;

$contextSubtract = new Context(new SubtractStrategy());
echo "Subtract: " . $contextSubtract->executeStrategy(10, 4) . PHP_EOL;

$contextMultiply = new Context(new MultiplyStrategy());
echo "Multiply: " . $contextMultiply->executeStrategy(7, 2) . PHP_EOL;
```

## Преимущества

* Позволяет выбирать алгоритмы во время выполнения программы.
* Избавляет от дублирования кода, связанного с различными вариантами алгоритмов.
* Позволяет добавлять новые алгоритмы без изменения существующего кода.

## Недостатки

* Увеличивает количество классов в системе, так как каждая стратегия требует свой собственный класс.